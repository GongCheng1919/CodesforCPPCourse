# 课程内容
> 这节课讲述了类的实例化、对象的初始化、构造函数和析构函数的概念及其在对象生命周期中的作用。
## 类的实例化

类的实例化指的是从类说明对象的过程。
按如下方式来说明对象（即该类的变量或称该类的实例）： 

```cpp
[自定义类类型名] [对象名 1], … ,[对象名 n];
```

若在该类的说明中含有带参数的构造函数，则在说明对象的同时，要给出具体实参初始化该对象。

对象和一般的数据类型一样，可以用来声明、定义类对象的数组、指针，也可以用来给同对象赋值，可以作为函数的形式参数、返回值

---
## 数据成员初始化

对于类的公有 `public` 数据成员，可以通过直接通过成员变量名访问并对其进行初始化

对于私有成员，可以通过 **公有的初始化函数** 以及 **构造函数** 对其进行初始化。
## 构造函数

构造函数语法：`类名(){}`，除此之外，构造函数还具有如下特点
>1. 构造函数没有返回值，也不写void
>2. 函数名与类名相同
>3. 构造函数可以有参数，因此可以发生重载
>4. 程序在创建对象的时候会自动调用构造函数，而且只会调用一次

构造函数按照功能可分为以下几种类型
#### **默认构造函数**
默认构造函数是默认的构造函数，默认构造函数通常没有参数，但它们可以具有带默认值的参数。

```cpp
class Box {
public:
    Box() { /*perform any required default initialization steps*/}

    // All params have default values
    Box (int w = 1, int l = 1, int h = 1): m_width(w), m_height(h), m_length(l){}
...
}
```

默认构造函数是特殊成员函数之一。 如果类中未声明构造函数，则编译器提供隐式 `inline` 默认构造函数。如果声明了任何非默认构造函数，**编译器不会提供默认构造函数**

#### 拷贝和赋值构造函数
参见 [第六章 引用和拷贝构造函数](https://github.com/GongCheng1919/CodesforCPPCourse/blob/master/%E7%89%B9%E8%89%B2%E7%8F%AD%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E8%AF%BE2-2/06-%E5%BC%95%E7%94%A8%E5%92%8C%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/README.md#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0)
#### **重载构造函数**

由于构造函数都是重载函数，其允许不同类型的形参列表，因此对于任意构造函数，其形参列表为本类对象时被默认调用，同时也允许不同类对象作为形参的形式

#### 显式默认构造函数

可以使用 `default` 关键字来默认设置任何特殊成员函数 — 以显式声明特殊成员函数使用默认实现、定义具有非公共访问限定符的特殊成员函数或恢复其他情况下被阻止其自动生成的特殊成员函数。

```cpp
struct widget {
	widget()= default;
	
	inline widget& operator=(const widget&);
};

inline widget& widget::operator=(const widget&) = default;
```

在需要默认行为时，建议将函数声明为默认构造函数，而不是空函数体。
#### 禁用构造函数

C++中使用 `delete` 关键字来禁用构造函数，从而阻止特定的构造函数被调用，以防止对象的拷贝、移动或默认构造等。 必须在声明函数时将其删除；不能在这之后通过声明一个函数然后不再使用的方式来将其删除。例如

```c++
struct widget
{
	// deleted operator new prevents widget from being dynamically allocated.
	void* operator new(std::size_t) = delete;
};
```

任何尝试使用被禁用的构造函数的代码都会导致编译错误。这是一种在编译时防止特定构造函数被调用的有效方式

---
#### 初始化表达式列表构造函数
构造函数初始化列表以一个冒号开始，接着是以逗号分隔的数据成员列表，每个数据成员后面跟一个放在括号中的初始化式。

```cpp
class CExample {
public:
    int a;
    float b;
    CExample(): a(0),b(8.8)
    {}
    CExample()
    {
        a=0;
        b=8.8;
    }
};
```

使用初始化表达式可以对变量成员进行显式的初始化，而直接在构造函数体内对成员赋值不会进行此项操作。这一特点在成员类型是**没有默认构造函数的类**、**const 成员** 或者 **引用类型** 的成员时特别有效
## 析构函数

析构函数在对象超出范围或通过调用 `delete` 或 `delete[]` 显式销毁对象时被自动调用，用于清理当前对象。其调用时机为
>1. 变量在离开其作用域时被销毁
>2. 当一个对象被销毁时，其成员被销毁
>3. 容器（无论是标准库容器还是数组）被销毁时，其元素被销毁
>4. 对于动态分配的对象，当对指向它的指针应用 `delete` 运算符时被销毁
>5. 对于临时对象，当创建它的完整表达式结束时被销毁

---
总的来说，构造函数和析构函数是类的要素，它们在一个对象的生存期的开始阶段和结束阶段起着举足轻重的作用。承担着对象的初始化和收尾工作。 
- 形象地说，每当对象“诞生”时，系统都将自动调用对象所属类的构造函数，以完成对象 的初始化工作； 
- 而每当对象“死亡”前，系统都将自动调用对象所属类的析构函数，以完成对 象撤销前的工作。

>在说明类对象指针时，不涉及类的实例化，因此不存在类对象的构 造和析构过程。 只有在使用 `new` 和 `delete` 进行类对象的动态生成和释放时，才会触发对应的构造和析构函数

# 实验题目
### Martix - 计算矩阵的行列式
给定矩阵的 行数 和 列数，使用 `mt19937` 随机数填充矩阵，并计算矩阵的秩

### Tensor - Tensor 类的构造与析构
构造一个 Tensor 张量类，使用 `mt19937` 随机数填充张量，重载 Tensor 类的 `[]` 运算符、共享内存拷贝构造函数、拷贝构造函数、赋值运算符和析构函数
