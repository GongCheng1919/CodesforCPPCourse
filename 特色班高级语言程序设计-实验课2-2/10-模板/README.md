# 课程内容
[模板](https://www.runoob.com/cplusplus/cpp-templates.html)是基于用户为模板参数提供的参数在编译时生成普通类型或函数的构造。
## 函数模板
函数模板定义的一般格式为：

```c++
template <typename type> ret-type func-name(parameter list) {
	...
}
```

函数模板可以像一般函数那样直接使用，用户只需给出具体的实参。在调用时，编译器按照如下顺序检查是否有可用函数
1. 是否有参数表恰与调用参数表完全相同的同名函数
2. 是否有函数模板经适当实例化成为参数匹配的同名函数
3. 是否有同名函数可经参数的自动转换后实现参数匹配（注意函数模板不允许类型转换）
如果都没有，抛出错误
***
## 类模板
类模板的说明就是一个带有模板参数的类定义，其格式为

```cpp
template <class type> class class-name {
	...
}
```

不能使用类模板来直接生成对象，因为其类型参数是不确定的，故需首 先对模板参数指定“实参”，从而将类模板实例化为某个具体的类，称为 #模板类

类模板的成员函数都是模板函数
#### 类模板的模板参数
类型参数：
- 类型参数是模板定义的主要用法，其主要反应了不同类型数据对应的同一种操作， 比如算数运算和逻辑运算等，对于强类型语言十分有必要。

非类型参数： 
- 非类型参数主要用于拓展模板的应用范围，使其除了可以定义不同类型的相同操作外，还可以类似函数一样设置不同类型的参数进行区分。
- 非类型参数只能为整型。
#### 类模板的静态成员
类模板也允许有静态成员。实际上它们是类模板的实例化类的静态成员。 
- 类模板的静态成员在类的实例化之后创建
- 对于一个类模板的同一个实例化类的所有的对象共享其静态成员
- 对于一个类模板的不同实例化类的对象之间不共享静态成员。
#### 类模板的友元
类模板定义中允许包含友元。说明一个友元类，实际上相当于说明该类的成员函数都是友元函数： 
- 如果该友元函数为一般函数，则它将是该类模板的所有实例化类的友元函数
- 如果该友元函数是一个函数模板，但其类型参数与类模板的类型参数无关，则该 函数模板的所有实例化函数都是类模板的所有实例化类的友元
- 如果该友元函数是一个函数模板，且它与类模板的类型参数有关，该友元函数模 板的实例有可能只是该类模板的某些特定实例化类的友元，而不是所有实例化的 模板类的友元
## 类模板的继承 与派生
#### 继承规则
继承过程中的基类一定是实例化后的模板类，也就是说不能使用不带类型参数的未实例化的类模板作为继承基类
#### 特例版本
在定义模板类的成员函数时，对需要特殊处理的类型，可以直接对该模板类实例化后的类定义成员函数，例如
```cpp
struct complex {
	...
};

void stack<complex>::showtop(){
	...
}
```

# 实验题目

 
