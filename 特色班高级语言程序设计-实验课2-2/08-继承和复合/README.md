# 课程内容
## 继承
面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。[菜鸟教程 继承](https://www.runoob.com/cplusplus/cpp-inheritance.html)

继承的一般格式为
```c++
class <类名>: <基类说明表>{
private: 
	<私有成员表>
protected:
	<保护成员表>
public:
	<公有成员表>
}
```
***
#### 基类成员在各自派生类中的存取权限
| 访问   | public | protected | private |
| ---- | ------ | --------- | ------- |
| 同一个类 | Y      | Y         | Y       |
| 派生类  | Y      | Y         | N       |
| 外部的类 | Y      | N         | N       |
***
#### 派生类的构造函数
构造派生类对象时，要对其**基类数据成员、所含对象成员的数据成员以及其他的新增数据成员**一起进行初始化，由派生类的构造函数通过**初始化列表**来完成的
***
#### 派生类的析构函数
释放派生类对象时系统的工作步骤与构造相反：先调用派生类自己的析构函数。再调用对象成员的析构函数，最后调用各基类的析构函数，所有调用顺序按照它们被继承时声明的相反顺序（从右到左）。
***
## 关系继承
#### 友元关系的继承
基类的友元不继承。即如果基类有友元类或友元函数，则其派生类不会因继承关系也一定有此友元类或友元函数

如果基类是某类的友元，则这种友元关系会被继承
***
#### 静态成员的继承
如果基类的静态成员是公有的或是保护的，则它们被其派生类继承为派生类的静态成员。
***
#### 赋值关系
基类对象和派生类对象之间的赋值关系如下
	派生类对象可以赋值给基类对象，仅复制共性成员，而基类对象不能赋值给派生类对象
	基类指针可指向派生类对象，但只能访问基类成员，访问派生类特有成员需强制转换。派生类指针不能指向基类对象。同时，派生类对象可以赋值给基类引用，但只能访问基类成员，基类对象则不能赋值给派生类引用。

派生类对象间的赋值操作依据下面的原则
	如果派生类有自己的赋值运算符的重载定义，即按该重载函数处理。 
	如果派生类未定义自己的赋值操作，而基类定义了赋值操作，则系统自动定义派生类赋值操作，其中基类成员的赋值按基类的赋值操作进行。
	二者都未定义专门的赋值操作，系统自动定义缺省赋值操作（浅拷贝）

## 二义性处理
对派生类而言，在派生类定义范围内以及通过派生类对象访问重名成员时，不加类名限定时默认处理派生类成员，通过类名限定才能访问基类的重名成员
## 虚基类
类 B 作为类 D1，D2，…，Dn 的基类，当把类 B定义为派生类 D1，D2，…，Dn 的虚基类时，各派生类的对象共享其基类 B 的一个拷贝，这种继承称为==共享继承==。

虚基类是为了解决由混合（多重多级）继承造成的二义性问题，其说明形式需要在继承前添加 `virtual` 关键字

```c++
class A {...};
class B: virtual public A {...};
class C: virtual public A {...};
class D: public B, public C {...};
```

# 实验题目

