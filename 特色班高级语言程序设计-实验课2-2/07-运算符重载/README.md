# 课程内容
可重载运算符 运算参数 运算符重载定义 运算符重载调用 运算符重载类型
## 运算符重载
#### 可重载运算符
- C++语言中的运算符实际上是函数的方便表示形式，例如，算术运算符“+”也可以表示为函数形式：
```
int add(int a,int b){
  return a+b;
}
```
这时，a+b和add(a,b)的含义是一样的。因此，逻辑上运算符也可以重载。
- C++语言规定，大多数运算符都可以重载，可重载的运算符如下：
```
(1) 单目运算符： -、~、！、++、--、new、delete
(2) 双目运算符： +、-、*、/、%、&、|、^、<<、>>、&&、||、==、！=、<、<=、>、>=、=、+=、-=、*=、/=、%=、^=、%=、|=、>>=、<<=、()、[]
```
- 所列可重载运算符几乎包含了 C++的全部运算符集，例外的是：
- **限定符 . 和：：。**
- **条件运算符 ?：。**
- **取长度运算符 sizeof。**
它们不可重载（不可赋予不同的操作）。
---
## 运算参数
- 算术运算符、逻辑运算符、位运算符和关系运算符中的<、>以及<=、>=，这些运算都与基本数据类型有关，通过运算符重载函数的定义，使它们也用于某些用户定义的数据类型。
- 指针运算符&和* 、下标运算符［］等运算所涉及的数据类型按 C++程序规定，并非只限于基本数值类型。因此，这些运算符可以自动地扩展到任何用户定义的数据类型，不需作重载定义就可“自动”地实现重载。
- 单目运算符++和--实际上各有两种用法：前缀增（减）量和后缀增（减）量。其运算符重载函数的定义当然是不同的，对两种不同的运算无法从重载函数的原型上予以区分：函数名（operator ++）和参数表完全一样。为了区别前缀++和后缀++，C++语言规定，在后缀++的重载函数的原型参数表中增加一个 int 型的无名参数。
```
前缀++:<类型>operator ++()  //作为类成员
<类型>operator++(<类型>)   //作为类外函数
后缀++:<类型>operator (int)  //作为类成员
<类型>operator++(<类型>，int) //作为类外函数
前缀++:++a或a.operator++()
operator++(a)
后缀++:a++或a.operator++(O)
operator++(a，0)
```
---
## 运算符重载定义
- 运算符的重载是一个特殊函数定义过程，这类函数总是以“operator<运算符>”作为函数名。
- 假设程序中定义了一个枚举类型的 Bool类型： enum Bool {FALSE, TRUE};
- 用运算符+(双目)、* (双目)、&(单目)来表示或、与、非运算是十分方便的
```
Bool operator+(Bool a,Bool b){
if((a==FALSE)&&(b==FALSE))return FALSE;
return TRUE;}
Bool operator(Bool a,Bool b){
if((a==TRUE&&b==TRUE))return TRUE;
return FALSE;}
Bool operator&(Bool a){
if(a==FALSE) return TRUE;
return FALSE;}
```
---
## 运算符重载调用
- 运算符重载函数的调用可有两种方式：
- - 与原运算符相同的调用方式，如上例中的 b1+b2、b1* b2 等。
- - 一般函数调用方式，如 b1+b2，也可以写为 operator+（b1，b2）。被重载的运算符的调用方式，优先级和运算顺序都与原运算符一致，其运算分量的个数也不可改变。
-  运算符重载主要用于同类的形式定义的用户定义类型，例如，复数类型、集合类型、向量类型等，通过运算符重载把人们习惯的运算符引入到计算操作中，会收到很好的效果。
```
b3=b1+b2;
b3=b1*b2;
b3=&b1;
b3=(b1+b2)*FALSE;
b3=operator+(b1,b2);
```
---
## 运算符重载类型
- 运算符重载和函数重载类似，通常可以划分为
  - 全局函数重载
  -  类成员函数重载
- 值得注意的是，有些运算符重载被限定为仅能通过类成员的方式进行重载，而不能进行全局函数重载，这些运算符包括：
- - 赋值运算符=： 赋值运算符是用于将一个对象的值赋给另一个对象。
- - 下标运算符[]： 下标运算符用于访问数组、容器或自定义类型的元素。
- - 函数调用运算符()： 函数调用运算符用于将对象作为函数调用。
---
## 类成员方式重载运算符
#### 重载方式
- 在自定义类中可以通过两种方式对运算符进行重载：
- - 按照类成员方式；
  - 按照友元方式。
- 运算符重载的定义是一个函数定义过程 ，其函数名处为operator <运算符>。
- 当以类的公有成员函数方式来重载运算符（也称为类运算符）时，具有如下特征:
- - 类成员函数内（定义处）可处理与使用本类的私有成员。
  - 总以当前调用者对象（*this）作为该成员函数的隐式第一运算分量，若所定义的运算多于一个运算对象时，才将其余运算对象显式地列在该成员函数的参数表中。
- 当以类的友元函数方式来重载运算符(也称为友元运算符)时，具有如下特征:
- - 友元函数内（定义处）可处理与使用本类的私有成员。
  - 所有运算分量必须显式地列在本友元函数的参数表中（由于友元函数中没有 this 指 针），而且这些参数类型中至少要有一个是说明该友元的类或是对该类的引用。
- 一般地说，单目运算符重载常选用成员函数方式，而双目运算符重载常选用友元函数方式。但不管选用哪种重载方式，对重载运算符的使用方法都是相同的。
-  注意，被用户重定义（重载）的运算符，其优先级、运算顺序（结合性）以及运算分量个数都必须与系统中的原运算符相一致，而且不可自创新的运算符。

# 实验题目
## complex——运算符重载：复数类的运算
描述： 请创建一个名为Complex的类，用于表示复数。这个类需要重载加法运算符+和减法运算符-，以便能够进行复数的加减运算。

输入： 输入包含两行，每行包含两个整数，分别表示复数的实部和虚部。

输出： 输出包含两行，第一行表示两个复数的和，第二行表示两个复数的差。每行输出的格式为"a + bi"，其中a和b分别表示复数的实部和虚部。
## gradient——运算符重载：计算浮点矩阵乘法和梯度
描述： 请创建一个名为Matrix的类，用于表示浮点数矩阵。

这个类需要重载乘法运算符*，以便能够进行矩阵的乘法运算。

该类还需要重载单目运算符!，以便能够计算矩阵的转置。

该类还需要实现一个mean成员函数用于计算当前矩阵的均值。

你需要实现A和B两个矩阵的乘法得到乘积C矩阵,并计算乘积C矩阵的均值.

你需要实现分别实现名为gradient_mean， gradient_dot的方法，分别用于计算均值和输入矩阵的梯度。
## polar——运算符重载：坐标运算
请创建一个名为Point和一个名为Polar的类，分别用于表示笛卡尔坐标和极坐标下的点。

实现这两个类的加和减法,需要重载加法运算符+和减法运算符-，以便能够进行笛卡尔坐标和极坐标的加减运算。

输入： 输入包含三行，前两行每行包含两个浮点数, 一个字符p/q分别表示Point和Polar的坐标, 最后一行输入一个字符+/-表示运算符。输入错误的符号则输出error

输出： 输出运算结果,运算结果应该为两行,第一行为笛卡尔坐标下的结果的两个坐标,第二行为极坐标下的运算结果的两个坐标。
注意:  对于极坐标,你总是需要将其坐标转换到笛卡尔坐标下进行计算，然后再转换回极坐标，来“加”这两个极坐标。极坐标的角度为弧度，范围为[-pai,pai]。 使用float数据类型来存储和计算坐标.，使用atan2计算弧度。
