# 课程内容
>  这节课讲述了函数重载的定义，函数重载条件，函数重载优先级，函数重载类型
## 函数重载定义
**对若干种不同的数据类型求和，虽然数据本身差别很大**（例如整数求和、向量求和、矩阵求和），具体的求和操作差别也很大， **但完成不同求和操作的函数却可以取相同的名字**（例如 sum、add 等）。

许多差别很大的打印函数可以都用同一个函数名 print，显示函数可以都用 display，从键盘或文件获取信息都称作 get，发送称为 send，接收称为 receive 等。

函数重载是指在同一个作用域内，可以定义多个具有相同名称但参数列表（参数类型、参数个数或参数顺序）不同的函数。函数重载使得程序可以根据不同的参数列表选择合适的函数进行调用，从而提高代码的灵活性和可复用性。
```
int abs ( int n) {return (n<O)? -n: n; }
float abs (float f){ if (f<O) f-f,return f; }
double abs (double d) { if (d<O) return -d; return d;}
```
#### 函数名的重载并不是为了节省标识符（标识符的数量是足够的），而是为了方便程序员的使用。
---
## 函数重载条件
- #### 实现函数的重载必须满足下列条件之一：
- 参数表中对应的参数类型不同。
- 参数表中参数个数不同。
- 参数表中不同类型参数的次序不同。
- #### 注意：返回类型不同是不能区分重载函数的。
```
void print ( int);     //整型
void print (point);    ////类point的对象
int sum (int，int);
int sum (int，int，int);
```
- #### 在定义同名函数时应注意：
- #### 返回类型不能区分函数
```
float add(int float); //错误
int add(int float);  //错误
```
- #### 采用引用参数不能区分函数
```
void print(double);
void print(double&); //错误
void print(const double&);  //错误
```
- #### 有些派生基本类型的参数虽然可以区分同名函数，但在使用中必须注意可能出现二义性。
- #### 包含可缺省参数时，可能造成二义性，应该尽量避免。
```
int abs(int);
int sum(int a,int b,int c=0;
unsigned int abs(unsigned int);
int sum(int a,int b);
```
---
## 重载优先级
- #### 二义性的情形是指系统面对某一函数调用语句，有两个或两个以上同名函数与之匹配，应该避免；
- #### 遇到无准确匹配的函数定义时，C++系统并不马上按出错处理，它按下面的方式处理：
- 通过数组名与指针变量、函数名与函数指针、某类型变量与const 常量之间的转换，去查看是否可实现匹配。
-  把实参类型从低到高（按字长由短到长）进行基本类型及其派生类型的转换，再检查是否可匹配。
-  查有无已定义的可变个数参数的函数，如有把它归为该函数。
-   在进行上述尝试性的处理之后可能出现仍无匹配或匹配不唯一的情况，这时可能输出错信息或错误地运行。
- #### 这种情况下，由于数据类型之间的复杂转换关系可能造成找不到与之匹配的函数定义。
---
## 函数重载类型
- #### 在C++中函数重载通常可以被划分为两个类型：
- 全局函数重载
- 类成员函数重载
- #### 全局函数重载意味着在整个程序中，该函数被说明为重载的，具有相同函数名不同参数列表的多个函数，程序运行时会根据按照优先级调用对应函数。
- #### 类成员函数则仅在类的范围内是可用的，仅能通过对象进行调用。
- #### 两者的调用方式不同。
---
## 运算符重载
#### 可重载运算符
- C++语言中的运算符实际上是函数的方便表示形式，例如，算术运算符“+”也可以表示为函数形式：
```
int add(int a,int b){
  return a+b;
}
```
这时，a+b和add(a,b)的含义是一样的。因此，逻辑上运算符也可以重载。
- C++语言规定，大多数运算符都可以重载，可重载的运算符如下：
```
(1) 单目运算符： -、~、！、++、--、new、delete
(2) 双目运算符： +、-、*、/、%、&、|、^、<<、>>、&&、||、==、！=、<、<=、>、>=、=、+=、-=、*=、/=、%=、^=、%=、|=、>>=、<<=、()、[]
```
- 所列可重载运算符几乎包含了 C++的全部运算符集，例外的是：
- **限定符 . 和：：。**
- **条件运算符 ?：。**
- **取长度运算符 sizeof。**
它们不可重载（不可赋予不同的操作）。
---
## 运算参数
- 算术运算符、逻辑运算符、位运算符和关系运算符中的<、>以及<=、>=，这些运算都与基本数据类型有关，通过运算符重载函数的定义，使它们也用于某些用户定义的数据类型。
- 指针运算符&和* 、下标运算符［］等运算所涉及的数据类型按 C++程序规定，并非只限于基本数值类型。因此，这些运算符可以自动地扩展到任何用户定义的数据类型，不需作重载定义就可“自动”地实现重载。
- 单目运算符++和--实际上各有两种用法：前缀增（减）量和后缀增（减）量。其运算符重载函数的定义当然是不同的，对两种不同的运算无法从重载函数的原型上予以区分：函数名（operator ++）和参数表完全一样。为了区别前缀++和后缀++，C++语言规定，在后缀++的重载函数的原型参数表中增加一个 int 型的无名参数。
```
前缀++:<类型>operator ++()  //作为类成员
<类型>operator++(<类型>)   //作为类外函数
后缀++:<类型>operator (int)  //作为类成员
<类型>operator++(<类型>，int) //作为类外函数
前缀++:++a或a.operator++()
operator++(a)
后缀++:a++或a.operator++(O)
operator++(a，0)
```
---
## 运算符重载定义
- 运算符的重载是一个特殊函数定义过程，这类函数总是以“operator<运算符>”作为函数名。
- 假设程序中定义了一个枚举类型的 Bool类型： enum Bool {FALSE, TRUE};
- 用运算符+(双目)、* (双目)、&(单目)来表示或、与、非运算是十分方便的
```
Bool operator+(Bool a,Bool b){
if((a==FALSE)&&(b==FALSE))return FALSE;
return TRUE;}
Bool operator(Bool a,Bool b){
if((a==TRUE&&b==TRUE))return TRUE;
return FALSE;}
Bool operator&(Bool a){
if(a==FALSE) return TRUE;
return FALSE;}
```
---
## 运算符重载调用
- 运算符重载函数的调用可有两种方式：
- - 与原运算符相同的调用方式，如上例中的 b1+b2、b1* b2 等。
- - 一般函数调用方式，如 b1+b2，也可以写为 operator+（b1，b2）。被重载的运算符的调用方式，优先级和运算顺序都与原运算符一致，其运算分量的个数也不可改变。
-  运算符重载主要用于同类的形式定义的用户定义类型，例如，复数类型、集合类型、向量类型等，通过运算符重载把人们习惯的运算符引入到计算操作中，会收到很好的效果。
```
b3=b1+b2;
b3=b1*b2;
b3=&b1;
b3=(b1+b2)*FALSE;
b3=operator+(b1,b2);
```


# 实验题目

