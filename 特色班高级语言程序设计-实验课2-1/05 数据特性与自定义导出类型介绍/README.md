# 数据特性与自定义导出类型介绍
## 常量与变量

C++程序中的数据可分为 [常量](https://github.com/GongCheng1919/CodesforCPPCourse/blob/master/%E7%89%B9%E8%89%B2%E7%8F%AD%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-%E5%AE%9E%E9%AA%8C%E8%AF%BE2-1/05%20%E6%95%B0%E6%8D%AE%E7%89%B9%E6%80%A7%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%BC%E5%87%BA%E7%B1%BB%E5%9E%8B%E4%BB%8B%E7%BB%8D/README.md#%E5%8F%98%E9%87%8F)（constant）与[[#变量]]（variable）两大类。在程序执行过 程中其值不能被改变的数据称为常量，其值可以改变的数据称为变量
***
#### 变量

变量是数据在程序中出现的主要形式，在变量第 1 次被使用前它应被说明。变量说明的格式为

```cpp
[<存储类>] <类型名或类型定义> <变量名表>
static long sum;
```

类型名或类型定义在任何变量说明语句中都必须包含不可缺省

变量名表可连续定义多个并赋初始值

```cpp
变量名表: <变量名>[=<表达式>], <变量名表>
int size, high, temp = 37;
```

***
###### 全局变量

全局变量是在任何函数或类外声明的变量，在整个程序中都可以访问。

全局变量所占用的内存空间在内存的数据区，在程序运行的整个过程中 **位置保持不变**
***
###### 局部变量

局部变量 是在函数或代码块内声明的变量，仅在该作用域内有效。简单地说，说明语句包含在某一对分割符“｛”和“｝”之内的变量为局部变量，否则为全局变量

局部变量占用的空间一般位于为程序运行时设置的 **临时** 工作区，以堆栈的形式允许反复占用和释放
***
###### 外部变量

使用 _`extern`_ 把变量声明为外部变量。 

一个变量被声明为外部变量，其含义是告诉系统不必为其分配内存，该变量已在这一局部的外面定义

外部变量一般用于由多个文件组成的程序中，有些变量在多个文件中被说明，但却是同一变量，指出某一变量为外部变量就避免了重复分配内存

可以在程序中多次说明 `extern` 变量，但是为 `extern` 变量赋初值会产生一个 `warn`，但是并不会出错，只是等价于 `extern` 失效
***
#### 常量

C++程序中的常量是指固定不变的量，有两种表示形式：一种称为有名常量，一种称为字面常量（literal constant）

- 字面常量的类型是 **根据书写形式** 来区分的。例如，475、200 是 int 型，3.1416、 200.0 是float 型，‘a’、‘4’、‘@’是 char 型

- **有名常量** 和 **变量** 在程序中必须遵循 **“先声明，后使用”** 的原则，程序中出现的所有有 名常量和变量都必须在使用前由常量说明语句和变量说明语句进行说明
***
###### 有名常量

有名常量说明语句的格式必须以关键字 _`const`_ 开头

```cpp
const <类型名><常量名> = <表达式>
const float pi = 3.1416;
```

表达式的值应与该常量类型一致的表达式

常量和变量都要求系统为其分配内存单元，所以可以把有名常量视为一种 **不允许赋值改变**的或**只读不写** 的变量，称为 `const` 变量

有名常量与宏定义的区别
> 宏定义也能定义常量，不过，用宏替换的方法定义符号常量与 `const` 方式的实现机制是不同的： 
> - 宏替换是在编译时把程序中出现的所有标识符 N 或 pai 都用 1000 和 3.1416 来替换，这里并 没有一个只读不写的 `const` 变量存在
> - 宏替换的方式中没有类型、值的概念，仅是两个字符串的代换

****
###### 字面常量
字面常量分为 4 类：_`int`_ 型常量、_`float`_ 型常量、_`char`_ 型常量和字符串常量。字面 常量是我们可以输入程序的量，简单来说，如果我们想给程序输入内容，只能是这 4 种类型的量
	
- _`int`_ 型常量即整型常量，实际上就是整数
	
- _`float`_ 型常量即浮点常量，浮点常量有两种表示法：
	- 小数点表示法：4.75、2.0、-473.385。 
	- 科学表示法：1.2e35、-7.37e-3
	
- `char` 常量即字符常量，如：'A'、'g'、'3'、'!。C++语言还定义了一些特殊的字符常 量，全是用反斜杠“＼”开头的，如下
	
| 字符常量    | ASCII码 | 含义     | 符号  |
| ------- | ------ | ------ | --- |
| `\a`    | 007    | 响铃     | BEL |
| `\b`    | 008    | 退格     | BS  |
| `\f`    | 012    | 走纸     | FF  |
| `\n`    | 010    | 换行     | LF  |
| `\r`    | 013    | 回车     | CR  |
| `\t`    | 111    | 水平制表   | HT  |
| `\v`    | 011    | 垂直制表   | VT  |
| `\\`    | 092    | 反斜杠    | \   |
| `\'`    | 044    | 单引号    | '   |
| `\"`    | 034    | 双引号    | "   |
| `\?`    | 063    | 问号     | ?   |
| `\0`    | 048    | 整数0    | NUL |
| `\DDD`  | 0DDD   | 八进制整数  |     |
| `\xHHH` | 0xHHH  | 十六禁止整数 |     |
- 字符串常量是用双引号括起来的字符序列，称为字符串常量
	
	一个字符串常量是一个特殊的字符序列或字符数组，其长度为该字符串中所有字符的 个数加 1。原因是除了保存串中字符（包括空格）之外，在最后存一串尾符'\0'。例 如，字符串常量"Pascal"的长度为 7。 
	
	字符串中也可包括特殊字符，如下。不过在使用特殊符号'\0' 时，会产生问题，系统 将把它作为串尾符而忽略了它后面的其他字符。
***
## 导出类型

导出数据类型并不是新的数据类型，而是定义在其他已定义类型基础上的 类型，而且其运算也是确定的。 C++语言中，导出类型主要有 3 种： 

- [[#数组类型]]：若干同一种类型数据（或对象）的组合。
- [[#指针类型]]：某一种类型数据（或对象）的首地址。 
- [[#引用类型]]：某一种类型数据（或对象）的引用。
***
#### 数组类型

在计算机所处理的数据中，最需要由计算机高速处理的数据是成批出现的**同一类型**的数据，C++语言中把这类数据称为数组。

数组（Array）不是一种独立的数据类型，称之为导出类型。任何一种类型的一批数据，都可以组成数组，例如 `int` 型、`float` 型、`char` 型数据可 以组成数组；这些基本类型的派生类型（如 `long` 型，`double` 型）的数据，枚举、结构、联合类型的数据，以及由用户或系统定义的类（类型）的对 象，都可以组成数组

数组可以是多维的，按照其维度可以称为一/二/三/…维数组
***
###### 一维数组

由 n 个同一类型数据组成的一维序列，构成一维数组，一维数组的下标为 0，…，n-1。 

任何一种已知类型数据都可说明为数组，数组说明的格式为： 

```cpp
<类型名><数组名>[<元素数>]={<初值表>}
```

- 类型名：可以是基本类型名、派生类型名、类名、枚举类型名、结构、联 合类型名（也可以是枚举、结构联合的类型说明）
- 数组名：标识符，用于表示数组元素的下标变量。如 array[2]表示数组的 第 3 个元素。同时也是一个指向数组的首元指针
- 元素数：一个正整数，指出数组的元素个数或数组的大小（size）。元素数要用方括号 `[]` 括起来。方括号 `[]` **不可缺省**，元素数则有时可缺省，省略时必须赋初值，系统按所赋的初值个数确定数组的大小
- 初值表：可缺省。是由花括号 `{}` 括起来且用逗号 `,` 分开的初始化常量值。

C++语言未提供对于数组整体进行操作的运算符和运算。对于数组的操作是通过对其元素，即下标变量进行的。下标变量的格式为： 

```cpp
<数组名>[<下标>]
```

下标：整数或整型表达式，其取值范围为 `0～n-1`，n=数组元素总数，例如：`int A[4];`共有 4 个下标变量：`A[0]、A[1]、A[2]、A[3]`

对于下标变量可进行赋值和运算操作，操作类似于单个变量

下标表达式应注意其值应保持在 0～n-1 范围之内(从0开始)
***
###### 多维数组

若干同一类型的数据形成 m 行 n 列的矩阵，则可称为二维数组，二维数 组亦可视为一维数组的数组。比如`int A[m][n];`说明了一个二维数组，它有 m×n 个元素，它也可以视为由 m 个一维数组 `int A[n]` 组成的（一维） 数组

类似地，还可以说明三维、四维数组，二维以上的数组统称为多维数组。 多维数组的说明与一维数组类似（以二维为例）： `<类型名><数组名>[<行数>][<列数>]` 
例如：`char ch[2][3];` 二维数组共有 2 行 3 列，元素个数为 2 × 3 = 6。 

在二维数组中，为数组赋初值的方式有两种： `int a[2][3]={{1，2，3}，{4，5，6}};` 和 `int a[2][3]={ 1，2，3，4，5，6 }` 

二者效果是一样的。系统将按逐行的次序，顺序为各元素赋值。由此可得，多维数组在内存中的存储也是一维线性存储的

对于多维数组的操作，同样是通过对其元素即下标变量的操作来进行的。 操作中应注意下标数量和表达式的取值范围： 

对于 `char A[m][n];` 的下标变量 `A[i][j]` 中 `i` 的值应在 `0～m–1` 之间，`j` 的值应在 `0～n–1` 之间

`A[i](0 <= i <= m–1)` 表示的是一个一维数组，其元素个数为 `n`，这些元素可用下标变量：`A[i][0]，A[i][1]，…，A[i][n-1]`
***
###### 数组与字符串

从表面上看，一个字符串就是一个字符数组，但在 C++语言中，二者并不 完全相同，在涉及字符串处理时，必须注意，字符串是一个以串尾符 `\0` 结尾的字符类型数组。 

```cpp
char string1[7] = "China";
char string2[] = "China";
char string3[7] = {'C', 'h', 'i', 'n', 'a'};
char string4[7] = {'C', 'h', 'i', 'n', 'a', '\0'};
```

这 4 个字符型数组是互不相同的

"China"是一个字符串常量，其字符串的长为 5，由 5 个字符组成，但存 放这一串常量却用 6 个字节，最后一个字节放串尾符 '\0'，因此：字符 数组 string1 的长度为 7，字符数组 string2 的长度为 6，字符数组 string3 的长度为 7，赋初值后前 5 个元素的值为'c'、'h'、 'i' 、'n'和 'a'。字符数组 string4 的长度为 7，赋初值后应与 string1 相同
***
#### 指针类型

指针（Pointer）类型的变量说明格式为：

```cpp
<类型名> *<指针变量名>=<初值>;
```
 + 类型名：任一基本类型名，基本类型的派生类型名，用户定义的类﹑枚举 类型﹑结构及联合类型名。 
	 + 类型名为 void 时，称为不确定类型的指针类型。 
	 + 类型名也可以是由 `<类型名>*` 表示的指针类型名，这时称为多级指针（指针类型的 指针）。 
- `符号*`：表示其后说明的变量为指针变量（这里的 `*` 不是运算符）
- 指针变量名：标识符
- 初值：可缺省。它可以是该类型的某一变量的地址。

注意：**指针本身也是一个变量，需要内存存储，也有地址和长度**

***

一个指针变量，可有 3 种状态：

- 未赋任何值，“悬空”状态。 

- 被赋予 NULL 值，未指向任一变量。 

- 指向某一变量的地址。

***

###### 指针赋值和使用

取地址运算&和取内容运算 `*` 
取地址运算为一单目运算，运算符为 `&`，例如： 

```cpp
int a=3,*pa=&a;
```

其中 `&a` 表示变量 `a` 的地址，它可以作为指针 `pa` 的值

使用&时应注意： 
- 其后只可用一个变量名，而不可用字面常量或一般表达式。(为什么？) 
- 赋值时，pa 与 a 的类型应一致

取内容运算为一单目运算，运算符为`*`，例如： 
```cpp
int a = 3,*pa = &a; 
*pa = 5; 
cout << a << *pa;
```

`*pa ＝ 5;`和 `cout << a << *pa;` 中的 `*pa` 表示指针 `pa` 当前所指向的变量 `a`，因此，`*pa=5; `相当于 `a=5;`，这里的 `*pa` 被称为“左值”，相当于变量 `a` 占用的空间，而后一个`*pa` 则相当于变量 `a` 的值，故二者显示出的值应是 `5`。第一行中的 `*pa` 要理解为说明 `pa`是 `int*` 类型的变量。

特别注意：`int* p`表示指针类型声明，但是 `*` 需要跟着 `p` 走而不是 `int` 走，
所以我们不能说 `int*` 表示 `int` 指针导出类型，如上的`int a=0, *p=NULL;`
***
###### 指针与数组的互相导出

如果指针变量是指向数组的，例如： 
```cpp
int a[20]; int *pa=a; 
```

则指针 pa 可以有限制地进行 `+、-` 运算或增量（`++`）减量（`––`）运算。这时，可以用 3 种方式表示该数组的元素： 

- 下标变量的形式：`a[0]，a[1]，a[2]，a[3]，…，a[19]`

- 用数组名 `a`（一个常量指针）：`*a，*(a+1)，*(a+2)，*(a+3)，…` 

- 用指针变量 `pa（=a）：*pa，*(pa+1)，*(pa+2)，*(pa+3)，…` 

3 种方式都可以，不过应注意的是，这里 `pa` 是变量，它可能是变化的，例 如： `pa+=3;` 执行后，`pa` 已指向 `a[3]`，即 `*pa` 为 `a[3]`。 `pa--;` 执行后，`pa` 已是指向 `a[2]`。

当数据为多维数组时，上述对应关系为： 
```cpp
int a[2][3]; 
int * pa = a[0]; //或 int * pa = &a[0][0]; 
```

注意：在二维数组 `a` 中，包括两个一维数组分量，其中，一维数组 `a[0]` 等同于 `&a[0][0]`，所以，`*a[0]`等同于`*(&a[0][0])`即 `a[0][0]`。

可用 3 种方式表示其 6 个元素：
- `a[0][0],a[0][1],a[0][2],a[1][0],a[1][1],a[1][2]`
- `*a[0],*(a[0] +1),*(a[0]+2),*(a[0]+3),*(a[0]+4),*(a[0]+5)` 
- `*pa,*(pa+1),*(pa+2),*(pa+3),*(pa+4),*(pa+5)`
***
###### 指向数组的指针
把数组作为整体，称指向这样一个整体的指针为指向数组的指针，对于这 类指针，其说明语句格式为

```cpp
<类型名> (*<指针变量名>)[<数组元素数>];
// e.g.
float A[2][4]; 
float (*pa) [4]; 
float *p=&A[0][0]; 
pa=A;
```

这时指针 `pa` 指向一维数组 `A[0]`（`A[0]`有 4 个元素），执行增量运算 `pa++; ` 后，pa 指向一维数组 `A[1]`，数组 `A[1]` 的 4 个元素

指针 `p` 和指针 `pa` 指向的地址是一样的，但 p 是指向一个整型下标变量 `A[0][0]`， 而 `pa` 则是指向整型一维数组 `A[0]`，前者占内存空间可能是 4 bytes，而后者则占 16 bytes

从指向数组指针和指向数组元素指针的区别可以看到：虽然指针变量的内容都是地址， 但指针变量的类型（指向的对象类型）则决定了该地址指向的存储区的大小。
***
###### 指针数组
指针数组 是由指针组成的数组，其说明格式为：

```cpp
<类型名>*<数组名>[<元素数>];
// n 维指针数组为： 
<类型名>*<数组名>[<元素数 1>][<元素数 2>]…[<元素数 n>];
```
直观的区别是： 
- 它比一般数组增加了符号`*`
- 它比指向数组的指针少了一对括号`()`。
***
###### 指针的运算

指针变量可以参加关系运算。这要分 3 种情况： 

- 一般指针可以进行相等和不等的比较，指向同一变量（地址）者为相等，否则不等。

- 任一指针可以和指针常量 NULL 进行相等和不等的比较。如一个指针 p 已经指向了某变量，则它不等于 NULL

- 数组指针可以指向该数组的各个元素，且一个数组的各个元素在内存中是顺序存放 的，故数组指针之间不但可以进行相等和不等比较，也可以进行大于、小于、大于 等于、小于等于等的比较。

指针和所有类型一样，也可进行赋值运算。
***
#### 引用

引用不仅像数组和指针那样依赖于已有的类型，而且它还 **依赖于一个已有的变量**。从直观上说，一个引用变量是一个已定义的变量的别名。 

引用变量的说明格式与指针变量说明相似： 

```cpp
<类型名>&<变量名>=<对象变量名> ;
```

与指针说明的区别是： 
- 用符号 `＆` 代替符号 `*`
- 赋初值部分不可缺省
***
###### 引用与指针的区别

指针表示的是一个对象变量的地址，而引用则表示一个对象变量的别名。因此在程序中表示其对象变量时，前者要通过取内容运算符`*`，而后者可直接代表。 

指针是可变的，它可以指向变量 m，也可以指向变量 n，而引用变量**只能在定义时一次确定**，不可改变。
***
###### 引用的其他特征

引用类型变量与其他类型变量不同，它没有自己的值和地址空间，只是作 为另一个变量的别名，在它的生存期期间两个名字绑定在一起，因此，引用类型的使用有如下限制

- 引用类型变量不能被引用
- 引用类型不能组成数组
- 引用类型不能定义指针
***
## 自定义类型
#### 枚举

`enum` 类型又称枚举类型，它是一种由用户参与定义的类型。其声明格式为
```cpp
enum <enum类型名> {<枚举值表>} <枚举变量表>;
```

enum 类型实际上是 int 型的一个子集，其每一个值对应一个整数

n 个枚举值全未赋常量值时，自左至右分别与整数 0～n-1对应

若第 i 个枚举值赋的常量值为整数 m，则其未赋常量值的后续枚举值分别与整数m+1、 m+2，…对应，直到下一个赋了值的枚举值或结束。因此，为枚举值所赋的整型常量值应自左至右递增。 

枚举类型变量只能赋予其值表中的值，且不能直接赋予数值。

枚举类型的说明亦可作为成组说明若干整型符号常量的方法。它不是完全由用户定义 的。
***
#### 结构

数组是把若干相同类型的数据放在一起，结构则是把若干不同类型的数据 放在一起，其声明格式为
```cpp
struct <类型名> { <成员表> };
```

结构类型的变量说明的格式为

```cpp
[struct] <结构类型名> <变量名表>;
```

struct 关键字在申明变量时可以省略（和枚举类型一样），也可以在申明结构体的同时申明变量，变量名表与一般变量说明一样，赋初始值的方法同数据的赋初值方式。

对结构类型的分量的存取由圆点运算符“.”实现，因此，为结构变量赋值，除了在变量说明中赋初值（如为 gy4 赋初值）的方法外，还可以用赋值语句或其他方式为结构分量赋值的方法，但是无论采用哪种方法为结构分量赋值，都 **必须保证类型一致**

结构类型的数据也可以组成数组，称为结构数组

结构与类的区别
> - 在缺省情况下，结构的成员是公有的（隐含为 public 属性）， 而类的成员是私有的（隐含为 private 属性）
***
#### 联合

联合构建了一系列数据成员的组合，但是所有数据成员重叠，都从同一位置开始存储。 

通常也只在要描述一批可重叠存放的数据成员时才使用联合 `union`。例如都是整型的 多个数据，比如 `int` 和 `char[4]` 的联合。 

```cpp
union int_float{
	/*data*/
	int int_value[4];
	float float_value[4];
};
```

不同编码的数据联合可能会产生意外的结果，比如int和float的联合体
***
#### 类和对象

一个类说明的常用格式为： 
```cpp
class <自定义类类型名> { 
private: 
	<各私有成员说明>; 
protected: 
	<各保护成员说明> ; 
public: 
	<各公有成员说明>; 
};
```
***
###### 访问限制

private 关键字后列出本类的私有成员，protected关键字列出本类的保护成员，public 关键字后列出本类的公有成员。 

private ，protected与 public 的顺序可以任意排列；每一个类型的控制属性均可以出现 多次或者一次也不出现；若紧随左花括号后的第一个控制属性为 private，则该 private 关键字可以省略（也就是说默认成员为private）。

只可在本类中对类的private成员进行访问，在别处是“不可见的”

类的protected成员可以在其派生类中访问和继承，但是不可被类外访问

类的public成员不仅在类中可以访问，而且在建立类对象的其他模块中，也可以通过 对象来访问
***
###### 类的成员

成员又区分为数据成员与函数成员（也称成员函数）两种。数据成员代表该类对象含 有的数据，描述的是该类对象的属性；而函数成员则代表如何对该类对象所含数据进 行操作的代码，描述的是对该类对象的处理方法。 

```cpp
a.public_attr;
a.public_func();
```

类所含有的成员函数既可放于类定义体的花括号之中，也可按类体外定义的方式放于 花括号之外进行说明（放在类体外说明时，类内必须有其函数原型，且类外函数说明 的前面必须用“<类名>::”来限定）。

```cpp
class A{ 
	public: void func(); 
} 

void A::func(){}
```
***
###### 类的声明

按如下方式来说明对象（即该类的变量或称该类的实例）： 

```cpp
<自定义类类型名> <对象名 1>, … ,<对象名 n>；
```

注意，若在该类的说明中含有带参数的构造函数，则在说明对象的同时，要给出具体 实参初始化该对象。此时说明对象的方式应改为： 

```cpp
<自定义类类型名> <对象名 1> ( <实参表 1> )， … ，<对象名 n> ( <实参表 n> ); 
```

与其他变量及结构变量类似，也可以说明类对象的数组（数组分量为对象）以及指向 对象的指针。另外，对象还可进行如下的操作与使用： 
- 同类型的对象间可以相互赋值
- 对象可作为函数参数（如对象作形参，对象指针作函数参数等）
- 函数的返回值可以是对象（或指向对象的指针）
- 可以在一个类中说明其他类的对象作为其数据成员等。

按如下方式来使用对象的成员（数据成员或函数成员）： 

```cpp
<对象名>.<成员名>
``` 
如果是一个指向对象的指针，我们可以使用如下两种方式来调用对象的成员： 

```cpp
*<指针>.<对象名> 或者 <指针>-><对象名>
```
